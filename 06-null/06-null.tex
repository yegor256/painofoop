% (The MIT License)
%
% Copyright (c) 2023 Yegor Bugayenko
%
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the 'Software'), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{article}
\usepackage{../painofoop}
\newcommand*\thetitle{NULL}
\newcommand*\thesubtitle{Fail Fast, Returning, Checking, OT}
\begin{document}

\plush{\poopTitlePage{6}}

\plush{\pptQuote{tony-hoare.jpg}{I call it my \emph{billion-dollar mistake}. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL~W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in \emph{the last forty years}.}{Tony Hoare, \href{https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/}{InfoQ}, 2009}}

\pptToc

\plush{\pptChapter[FailFast]{Fail Fast vs Fail Safe}}

\plush{\pptQuote{james-shore.jpg}{Over time, more and more errors will fail fast, and you'll see the cost of debugging decrease and the quality of your system improve}{James Shore, IEEE Software, 2002}}

\pptSection{Defaults}
\begin{pptWide}{2}
Fail Safe:\par
{\small\begin{ffcode}
int size(File file) {
  if (!file.exists()) {
    return 0;
  }
  return file.length();
}
\end{ffcode}
}
\par\columnbreak\par
Fail Fast:\par
{\small\begin{ffcode}
int size(File file) {
  if (!file.exists()) {
    throw new IllegalArgumentException(
      "The file is absent :("
    );
  }
  return file.length();
}
\end{ffcode}
}
\end{pptWide}
\par
The right snippet is more \emph{fragile}, leading to more errors in runtime, but eventually ... leading to less bugs.
\plush{}

\pptSection[Swallowing]{Exception swallowing}
\begin{pptWide}{2}
{\small\begin{ffcode}
String read(File file) {
  try {
    return new String(
      Files.readBytes(file)
    );
  } catch (IOException e) {
    e.printStackTrace();
  }
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
String read(File file) {
  try {
    return new String(
      Files.readBytes(file));
  } catch (IOException e) {
    throw new IllegalStateException(
      String.format(
        "Can't read file %s", e.name()),
      e);
  }
}
\end{ffcode}
}
\end{pptWide}
\par
The right snippet is \emph{escalating}, while the left one is \emph{swallowing}.
\plush{}

\pptSection[SDLC]{Software development lifecycle}
\par
\begin{tikzpicture}[every path/.style={->, draw, color=gray, line width=5pt}, every node/.style={font=\large, color=black}]
\node[] (fix) {Fix};
\node[above right=4cm of fix] (deploy) {Deploy};
\node[right=9cm of fix] (use) {Use};
\node[below right=4cm of fix] (report) {Report};
\path (fix) -- (deploy);
\path (deploy) -- (use);
\path (use) -- (report);
\path (report) -- (fix);
\path[dashed] (use) -- (fix);
\end{tikzpicture}
\par
Watch this video from DEVit'2016 conference: \\
\href{https://www.youtube.com/watch?v=nCGBgI1MNwE}{Need It Robust?Make It Fragile!}
\plush{}

\plush{\pptChapter[Returning]{Alternatives to Returning NULL}}

\pptSection[Return]{Returning NULL or raising an error?}
\begin{pptWide}{2}
{\small\begin{ffcode}
String nameOfEmployee(int id) {
  if (em.existsInDb(id)) {
    return null;
  }
  return em.readFromDb(id);
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
String nameOfEmployee(int id) {
  if (em.existsInDb(id)) {
    throw new EmployeeNotFound(id);
  }
  return em.readFromDb(id);
}
\end{ffcode}
}
\end{pptWide}
\par
The right snippet is ``Fail Fast,'' that's why more preferrable.
\plush{}

\pptSection[List]{Returning a List or a NULL?}
\begin{pptWide}{2}
{\small\begin{ffcode}
String nameOfEmployee(int id) {
  if (em.existsInDb(id)) {
    return null;
  }
  return em.readFromDb(id);
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
List<String> nameOfEmployee(int id) {
  List<String> names =
    new ArrayList<>(0);
  if (em.existsInDb(id)) {
    return names;
  }
  names.add(em.readFromDb(id));
  return names;
}
\end{ffcode}
}
\end{pptWide}
\par
There are mo elegant alternatives in most languages, like |Optional| in Java~8+.
\plush{}

\plush{\begin{pptMiddle}
  \pptPic{0.8}{tweet-vote.png}
\end{pptMiddle}}

\pptSection[Fake]{Returning a Fake Entity}
\begin{pptWide}{2}
{\small\begin{ffcode}
Employee employee(int id) {
  if (em.existsInDb(id)) {
    return null;
  }
  return new PgEmployee(id);
}

e = employee(42);
print(e.id());
print(e.salary());
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Employee employee(int id) {
  if (em.existsInDb(id)) {
    return FakeEmployee(id);
  }
  return new PgEmployee(id);
}

e = employee(42);
print(e.id());

print(e.salary());
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\plush{\pptChapter[Checking]{Alternatives to Checking for NULL}}

\pptSection[??-operator]{null-coalescing operator in C\#}
\begin{pptWide}{2}
{\small\begin{ffcode}
int? sizeOf(File f) {
  if (f.exists()) {
    return null;
  }
  return f.size();
}

int? s = sizeOf(f);
if (s == null) {
  s = 0;
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
int? sizeOf(File f) {
  if (f.exists()) {
    return null;
  }
  return f.size();
}

int s = sizeOf(f) ?? 0;
\end{ffcode}
}
\end{pptWide}
\par
Both snippets are bad design, though. They are workarounds.
\plush{}

\pptSection[Ruby]{\texttt{\&.} operator in Ruby}
\begin{pptWide}{2}
{\small\begin{ffcode}
def employee(id)
  unless db.exists?(id)
    return nil
  end
  return db.get(id)
end

e = employee(42)
puts e.name unless e.nil?
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
def employee(id)
  unless db.exists?(id)
    return nil
  end
  return db.get(id)
end

puts employee(42)&.name
\end{ffcode}
}
\end{pptWide}
\par
Actually, the snippets produce different output when the employee is not found. How are they different?
\plush{}

\pptSection[Kotlin]{NULL-awareness in Kotlin}
\pptPin{\pptPic{0.9}{elvis-operator.jpg}}
{\small\begin{ffcode}
var a: String = "abc"
a = null // compilation error

var b: String? = "abc"
b = null // no error here

println(b?.length) // prints what?
println(b?.length ?: -1) // Elvis operator
\end{ffcode}
}
\plush{}

\plush{\pptChapter[Checking]{Alternatives to Storing NULL}}

\pptSection[Immutability]{Immutable objects}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Employee {
  private String name = null;
  void setName(String n) {
    this.name = n;
  }
}

e = new Employee();
e.setName("Jeff");
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
class Employee {
  private final String name;
  Employee(String n) {
    this.name = n;
  }
  Employee withName(String n) {
    return new Employee(n);
  }
}

e1 = new Employee();
e2 = e1.withName("Jeff");
\end{ffcode}
}
\end{pptWide}
\plush{}

\plush{\pptChapter[OT]{Object Thinking}}

\pptBanner{Pay respect to your objects!}
\begin{pptWide}{2}
{\small\begin{ffcode}
d = getDepartment(42);
e = d.getEmployee("Jeff");
if (e != null) {
  printf("Hello, %s", e.name());
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
- Hello, is it the department no.42?
- Yes.
- Let me talk to your employee "Jeff".
- Hold the line please...
- Hello.
- Are you NULL?
\end{ffcode}
}
\includegraphics[width=3in]{oops.jpg}
\end{pptWide}
\par
\plush{}

\plush{\pptChapter[Spring]{Spring Boot}}

\plush{
  \pptPic{0.8}{tweet.png}
  \par
  You can do you own analysis of existing Java open source GitHub repositories to see how often their developers use |null| keyword.
  \par
  The Takes framework is here: \href{https://github.com/yegor256/takes}{yegor256/takes}.
}


\plush{\pptChapter[R\&W]{Read and Watch}}

\href{https://www.yegor256.com/2014/05/13/why-null-is-bad.html}{Why NULL is Bad?} by me (2014)

\href{https://www.yegor256.com/2015/12/01/rethrow-exceptions.html}{Throwing an Exception Without Proper Context Is a Bad Habit} by me (2015)

\href{https://www.yegor256.com/2018/05/22/default-arguments-against-null.html}{One More Recipe Against NULL} by me (2018)

\href{https://www.yegor256.com/2015/08/25/fail-fast.html}{Need Robust Software? Make It Fragile} by me (2015)

\href{https://www.youtube.com/watch?v=o3aNJX7AP3M}{What is Wrong About NULL in OOP? (Webinar \#3)} by me on YouTube (2015)

\end{document}
