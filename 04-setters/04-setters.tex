% (The MIT License)
%
% Copyright (c) 2023-2024 Yegor Bugayenko
%
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the 'Software'), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{article}
\usepackage{../painofoop}
\newcommand*\thetitle{Setters}
\newcommand*\thesubtitle{Mutability, Problems, DTO and ORM}
\begin{document}

\plush{\poopTitlePage{4}{h0jf9E1tjf4}}

\pptToc

\plush{\pptChapter{Pre-Test}}

\pptSection[How?]{How would you do this?}
\begin{pptWide}{2}
{\small\begin{ffcode}
Message m = new Message();
m.setName("Sarah");
m.print(); // Hello, Sarah!

m.setName("Victor");
m.print(); // Hello, Victor!

m.setName("Leyla");
m.print(); // Hello, Leyla!
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Message m1 = new Message("Sarah");
m1.print(); // Hello, Sarah!

Message m2 = new Message("Victor");
m2.print(); // Hello, Victor!

Message m3 = new Message("Leyla");
m3.print(); // Hello, Leyla!
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\plush{\pptChapter{Mutability}}

\pptSection[Definition]{Which object is \ul{im}mutable?}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Book {
  private String title;
  Book(String t) { title = t; }
  void setTitle(String t) {
    this.title = t;
  }
  String getTitle() {
    return this.title;
  }
}
b = new Book();
b.setTitle("Object Thinking");
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
class Book {
  private final String title;
  Book(String t) { title = t; }
  void withTitle(String t) {
    return new Book(t);
  }
  String getTitle() {
    return this.title;
  }
}
b1 = new Book();
b2 = b1.withTitle("Object Thinking");
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\print{\pptSection[Gradients]{There are four gradients of immutability}}
\print{I. Constant}
\print{II. Not a Constant}
\print{III. Represented Mutability}
\print{IV. Encapsulated Mutability}
\plush{{\small You may read my blog about this~\citep{bugayenko2016blog0907}.\par}}

\pptSection[Constant]{Gradient I: Constant}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Book {
  private final String t;
  Book(String t) { this.t = t; }
  String title() {
    return this.t;
  }
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Book b = new Book("Object Thinking");
String t1 = b.title();
String t2 = b.title()
\end{ffcode}
}
\par
The \ff{title()} method returns exactly the same data on each call.
This object is definitely \ul{immutable}.
\end{pptWide}
\par
\plush{}

\pptSection[NotConstant]{Gradient II: Not a Constant}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Book {
  private final String t;
  Book(String t) { this.t = t; }
  String title() {
    return String.format(
      "%s / %s", title, new Date()
    );
  }
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Book b = new Book("Object Thinking");
String t1 = b.title();
String t2 = b.title()
\end{ffcode}
}
\par
The \ff{title()} method returns different data on each new call,
depending on \ul{system timer}.
Does it make the object mutable or not?
\end{pptWide}
\par
\plush{}

\pptSection[Represented]{Gradient III: Represented Mutability}
\begin{pptWide}{2}
{\scriptsize\begin{ffcode}
class Book {
  private final Path path;
  Book(Path p) { this.path = p; }
  Book rename(String title) {
    Files.write(
      this.path,
      title.getBytes(),
      StandardOpenOption.CREATE
    );
    return this;
  }
  String title() {
    return new String(
      Files.readAllBytes(this.path)
    );
  }
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Book b = new Book("Object Thinking");
String t1 = b.title();
b.rename("Elegant Objects");
String t2 = b.title()
\end{ffcode}
}
\par
The \ff{title()} method returns different data on each new call,
depending on the content of the \ul{file} in the \ul{file system}.
Does it make the object mutable or not?
\end{pptWide}
\par
\plush{}

\pptSection[Encapsulated]{Gradient IV: Encapsulated Mutability}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Book {
  private final StringBuffer buffer;
  Book rename(String t) {
    this.buffer.setLength(0);
    this.buffer.append(t);
    return this;
  }
  String title() {
    return this.buffer.toString();
  }
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
Book b = new Book("Object Thinking");
String t1 = b.title();
b.rename("Elegant Objects");
String t2 = b.title()
\end{ffcode}
}
\par
The \ff{title()} method returns different data on each new call,
depending on the content of the \ul{memory block}.
Does it make the object mutable or not?
\end{pptWide}
\par
\plush{}

\plush{
\pptThought{Only gradients III and IV cause problems, while ``Constant'' and ``Not a Constant'' objects are harmless.}
\par
{\small You may want to read my blog about immutability~\citep{bugayenko2014blog0609,bugayenko2014blog1222,bugayenko2014blog1209,bugayenko2014blog1107}.\par}}

\plush{\pptChapter[Problems]{Drawbacks of Mutability}}

\qte
  {joshua-bloch}
  {Immutable classes are \ul{easier to design}, implement, and use than mutable classes. They are \ul{less prone to error} and are \ul{more secure}.}
  {bloch2008effective}

\qte
  [Steve Freeman]
  {steve-freeman}
  {Writing large-scale functional programs is a topic for a different book, but we find that a little immutability within the implementation of a class leads to \ul{much safer} code and that, if we do a good job, the code \ul{reads well} too.}
  {freeman2009growing}

\pptSection[Side-effects]{1) Side effects}
\begin{pptWide}{2}
With a side effect:\par
{\small\begin{ffcode}
public String post(Request request) {
  request.setMethod("POST");
  return request.fetch();
}

r = new Request("x.com");
r.setMethod("GET");
String first = this.post(r);

String second = r.fetch();
\end{ffcode}
}
\par\columnbreak\par
Without a side effect:\par
{\small\begin{ffcode}
public String post(Request request) {
  return request
    .withMtd("POST")
    .fetch();
}

r = new Request("x.com").withMtd("GET");
String first = this.post(r);

String second = r.fetch();
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\pptSection[Concurrency]{2) Thread (un-)safety}
\begin{pptWide}{2}
{\small\begin{ffcode}
class Books {
  private int c = 0;
  void add() {
    this.c = this.c + 1;
  }
}
\end{ffcode}
\begin{tabular}{l>{\raggedright}p{11cm}}%
  \raisebox{-0.9\height}{\pptPic{0.2}{goetz.png}} & \small \citet{goetz2006java} explained the advantages of immutable objects
  in more details in their very famous book ``Java Concurrency in Practice'' (highly recommended!) \\
\end{tabular}
}
\par\columnbreak\par
{\small\begin{ffcode}
ExecutorService e =
  Executors.newCachedThreadPool();
final Books books = new Books();
for (int i = 0; i < 1000; i++) {
  e.execute(
    new Thread(
      () -> {
        books.add();
      }
    )
  );
}
// What is the value of "books.c"?
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\pptSection[Coupling]{3) Temporal Coupling}
\begin{pptWide}{2}
{\small\begin{ffcode}
r = new Request("x.com");
r.setMethod("POST");
String first = r.fetch();
r.setBody("text=hello");
String second = r.fetch();
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
r = new Request("x.com");

// 100 lines later:
// r.setMethod("POST");
// String first = r.fetch();

r.setBody("text=hello");
String second = r.fetch();
\end{ffcode}
}
\end{pptWide}
\par
``\ul{Sequential} coupling (also known as \ul{temporal} coupling) is a form of coupling where a class requires its methods to be called in a particular sequence.'' --- \href{https://en.wikipedia.org/wiki/Sequential_coupling}{Wikipedia}.
\plush{}

\qte
  {robert-martin}
  {Side effects are \ul{lies}. Your function promises to do one thing, but it also does other hidden things. They are devious and damaging mistruths that often result in strange \ul{temporal couplings} and order dependencies.}
  {martin2008clean}

\qte
  {steve-mcconnell}
  {Sequential cohesion (considered to be less than ideal) exists when a routine contains operations that must be performed in a \ul{specific order}, that share data from step to step, and that don't make up a complete function when done together.}
  {mcconnell1998}

\qte
  {michael-feathers}
  {Back in the early days of programming, this was named temporal coupling, and it is a pretty \ul{nasty thing} when you do it excessively. When you group things together just because they have to happen at the same time, the relationship between them isnâ€™t very strong. Later you might find that you have to do one of those things without the other, but at that point they might have grown together. Without a seam, separating them can be hard work.}
  {feathers2004working}

\pptSection[Identity]{4) Identity Mutability}
\begin{pptWide}{2}
{\small\begin{ffcode}
Map<Date, String> map = new HashMap<>();
Date date = new Date();
map.put(date, "hello, world!");
assert map.containsKey(date); // It is TRUE

date.setTime(12345L);
assert map.containsKey(date); // Why FALSE??
\end{ffcode}
}
\par\columnbreak\par
\end{pptWide}
\par
\plush{}

\plush{\pptChapter{ORM}}

\plush{
\pptThought{ORM stands for ``Object Relational Mapping,'' which is an attempt to represent a relational data model in objects and relations between them, such as attributes, methods, and inheritance}
\par
{\small You may want to read my blog about ORM~\citep{bugayenko2014blog1201}.\par}}

\qte
  {ted-neward}
  {One of the first and most easily-recognizable problems in using objects as a front-end to a relational data store is that of \ul{how to map} classes to tables.}
  {neward2006vietnam}

\pptSection[JPA]{Java Persistence API}
\begin{pptWide}{2}
{\small\begin{ffcode}
@Entity
@Table(name = "movie")
public class Movie {
  @Id
  private Long id;
  private String name;
  private Integer year;
  // ctors
  // getters
  // setters
}
\end{ffcode}
}
\par\columnbreak\par
{\small\begin{ffcode}
EntityManager em = getEntityManager();
em.getTransaction().begin();
Movie movie = em.findById(1L);
movie.setName("The Godfather");
em.persist(movie);
em.getTransaction().commit();
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\pptSection[SQL-speaking]{SQL speaking objects}
\begin{pptWide}{2}
{\small\begin{ffcode}
interface Movie {
  int id();
  String title();
  String author();
}
Movie m = new PgMovie(ds, 1L);
m.update("The Godfather");
\end{ffcode}
}
\par
Here I'm using \href{https://github.com/jcabi/jcabi-jdbc}{jcabi-jdbc},
an object-oriented wrapper around JDBC data source.
\par\columnbreak\par
{\scriptsize\begin{ffcode}
final class PgMovie implements Movie
  private final Source dbase;
  private final int number;
  public PgMovie(DataSource data, int id)
    this.dbase = data;
    this.number = id;
  public String title()
    return new JdbcSession(this.dbase)
      .sql("SELECT title FROM movie WHERE id = ?")
      .set(this.number)
      .select(new SingleOutcome<String>(String.class));
  public void rename(String n)
    new JdbcSession(this.dbase)
      .sql("UPDATE movie SET name = ? WHERE id = ?")
      .set(n)
      .set(this.number)
      .execute();
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\pptSection[JOINs]{Complex SQL queries}
\begin{pptWide}{2}
{\small\begin{ffcode}
final class PgMovies
  private final Source dbase;
  public PgMovies(DataSource data)
    this.dbase = data;
  public Movie movie(Long id)
    return new PgMovie(this.dbase, id);
\end{ffcode}
}
\par\columnbreak\par
{\scriptsize\begin{ffcode}
final class PgMovie implements Movie
  private final Source dbase;
  private final int number;
  public PgMovie(DataSource data, int id)
    this.dbase = data;
    this.number = id;
  public String title()
    return new JdbcSession(this.dbase)
      .sql("SELECT title FROM movie WHERE id = ?")
      .set(this.number)
      .select(new SingleOutcome<String>(String.class));
  public String author()
    return new JdbcSession(this.dbase)
      .sql("SELECT name FROM movie JOIN author ON author.id = movie.author WHERE movie.id = ?")
      .set(this.number)
      .select(new SingleOutcome<String>(String.class));
\end{ffcode}
}
\end{pptWide}
\par
\plush{}

\plush{\pptChapter[Apache]{Apache Commons Email}}

\plush{\pptChapter[Performance]{What About Performance?}}

\qte
  [Zoran Budimli{\'c}]
  {zoran-budimlic}
  {Although Java implementations have been made great strides, they still \ul{fall short} on programs that use the full power of Java's object-oriented features. Ideally, future compiler technologies will be able to \ul{automatically transform} the [OO style code] into something that approaches the [procedural style] in performance.}
  {budimlic1999cost}

\end{document}
